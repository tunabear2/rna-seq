##온라인 GSEA 포멧만들기
GSEA
모든 유전자를 log2FC 기준으로 순위를 매기고, Entrez id가 없는 gene은 배제해야하고, shrinkLFC 값을 사용해야 한다고함.
## res_shrink >- lfcShrink(dds, contrast = c("condition", "Treat", "Control"), type = "apeglm")
DESeq2 진행 후에 하기

R에서 진행 방법 (entrezid 방법)
fgsea,,

gsea_data <- filter(res_df, !is.na(ENTREZID))
ranks <- gsea_data$stat
names(ranks) <- gsea_data$ENTREZID
ranks_filter <- ranks[!is.na(ranks)]
barplot(sort(ranks_filter, decreasing = TRUE))
msig_h <- msigdbr(db_species = "HS", species = "human", collection = "C5")

sum(duplicated(names(ranks_filter))) # 중복된 이름 제거
head(names(ranks_filter)[duplicated(names(ranks_filter))])
r <- ranks_filter
r <- r[order(abs(r), decreasing = TRUE)]
r <- r[!duplicated(names(r))]
r
ranks_unique <- r

msigdbr_list <- split(x = msig_h$ncbi_gene, f = msig_h$gs_name)

S1_vs_S2_gsea <- fgsea(pathways = msigdbr_list, stats = ranks_unique) # pathways에는 list형태가 input으로 들어가야 한다고 함.




res_list <- list(
  S1_vs_S2 = S1_vs_S2,
  S1_vs_S3 = S1_vs_S3,
  S1_vs_S4 = S1_vs_S4,
  S2_vs_S3 = S2_vs_S3,
  S2_vs_S4 = S2_vs_S4,
  S3_vs_S4 = S3_vs_S4
)

make_rank <- function(df, id_col = "ENTREZID", score_col = "stat") {
  stopifnot(id_col %in% colnames(df), score_col %in% colnames(df))
  
  x <- df[, c(id_col, score_col)] %>%
    mutate(
      id = as.character(.data[[id_col]]),
      score = as.numeric(.data[[score_col]])
    ) %>%
    filter(!is.na(id), id != "", is.finite(score))
  
  # 중복 ID가 있으면 |score| 최대인 것만 대표로
  score_rep <- tapply(x$score, x$id, function(v) v[which.max(abs(v))])
  
  rank_vec <- sort(unlist(score_rep), decreasing = TRUE)
  rank_vec
}

msig_h <- msigdbr(species = "Homo sapiens", category = "H") %>%
  filter(!is.na(entrez_gene)) %>%
  distinct(gs_name, entrez_gene)

pathways <- split(msig_h$entrez_gene, msig_h$gs_name)
length(pathways)

outdir <- file.path("rsem", "results", "gsea", "HALLMARK_by_stat")
dir.create(outdir, recursive = TRUE, showWarnings = FALSE)

run_gsea_one <- function(df, comp_name, pathways, outdir,
                         id_col = "ENTREZID", score_col = "stat",
                         minSize = 15, maxSize = 500, nperm = 10000,
                         top_plot = 5) {
  
  # (권장 체크) 너무 적은 row면 "sig만 있는 객체"일 가능성
  if (nrow(df) < 3000) {
    warning(comp_name, " : rows가 너무 적어 보여. GSEA는 전체 gene results가 필요해. (지금 nrow=", nrow(df), ")")
  }
  
  ranks <- make_rank(df, id_col = id_col, score_col = score_col)
  
  fg <- fgsea(
    pathways = pathways,
    stats    = ranks,
    minSize  = minSize,
    maxSize  = maxSize,
    nperm    = nperm
  ) %>% as.data.frame() %>%
    arrange(padj, desc(abs(NES))) %>%
    mutate(comparison = comp_name)
  
  # 결과 저장
  fwrite(fg, file.path(outdir, paste0(comp_name, "_fgsea.csv")))
  
  # 상위 enrichment plot 저장(양/음 방향 각각)
  fg_sig <- fg %>% filter(!is.na(padj)) %>% arrange(padj)
  if (nrow(fg_sig) > 0) {
    top_pos <- fg_sig %>% filter(NES > 0) %>% slice_head(n = top_plot)
    top_neg <- fg_sig %>% filter(NES < 0) %>% slice_head(n = top_plot)
    
    plot_terms <- c(top_pos$pathway, top_neg$pathway)
    plot_terms <- unique(plot_terms)
    
    for (pw in plot_terms) {
      p <- plotEnrichment(pathways[[pw]], ranks) +
        ggtitle(paste0(comp_name, " | ", pw))
      ggsave(
        filename = file.path(outdir, paste0(comp_name, "__", pw, "_enrichment.png")),
        plot = p, width = 7, height = 4, dpi = 300
      )
    }
  }
  
  fg
}

# 전체 비교군 실행
all_fgsea <- bind_rows(lapply(names(res_list), function(nm) {
  run_gsea_one(
    df = res_list[[nm]],
    comp_name = nm,
    pathways = pathways,
    outdir = outdir,
    id_col = "ENTREZID",
    score_col = "stat",
    minSize = 15, maxSize = 500,
    nperm = 10000,
    top_plot = 5
  )
}))

# 통합 결과 저장
fwrite(all_fgsea, file.path(outdir, "ALL_COMPARISONS_fgsea.csv"))


-----------------------------------------------------------------------
list만든 이후 진행.
make_rank_ens <- function(df, id_col = "gene_id", score_col = "stat") {
  stopifnot(id_col %in% colnames(df), score_col %in% colnames(df))
  
  x <- df[, c(id_col, score_col)]
  x[[id_col]] <- as.character(x[[id_col]])
  x[[score_col]] <- as.numeric(x[[score_col]])
  
  # ENSEMBL 버전(.숫자) 있으면 제거 (이미 정리돼 있어도 안전하게)
  x[[id_col]] <- sub("\\..*$", "", x[[id_col]])
  
  x <- x[!is.na(x[[id_col]]) & x[[id_col]] != "" & is.finite(x[[score_col]]), , drop = FALSE]
  
  # 중복 ENSEMBL이 있으면 |stat| 최대값 1개로 대표
  rep_score <- tapply(x[[score_col]], x[[id_col]], function(v) v[which.max(abs(v))])
  
  ranks <- sort(unlist(rep_score), decreasing = TRUE)
  ranks
}

suppressPackageStartupMessages({
  library(dplyr)
  library(msigdbr)
  library(org.Hs.eg.db)
  library(AnnotationDbi)
})

get_hallmark_pathways_ensembl <- function() {
  msig <- msigdbr(species = "Homo sapiens", category = "H")
  
  # (A) 혹시 msigdbr에 ENSEMBL 컬럼이 이미 있으면 그걸 우선 사용
  ens_cols <- intersect(c("ensembl_gene", "ensembl_gene_id", "ensembl"), colnames(msig))
  if (length(ens_cols) > 0) {
    msig2 <- msig %>%
      transmute(gs_name, ENSEMBL = sub("\\..*$", "", as.character(.data[[ens_cols[1]]]))) %>%
      filter(!is.na(ENSEMBL), ENSEMBL != "")
  } else {
    # (B) 없으면 SYMBOL -> ENSEMBL 매핑
    stopifnot("gene_symbol" %in% colnames(msig))
    
    sym_keys <- unique(na.omit(msig$gene_symbol))
    map <- AnnotationDbi::select(
      org.Hs.eg.db,
      keys     = sym_keys,
      keytype  = "SYMBOL",
      columns  = c("SYMBOL", "ENSEMBL")
    ) %>%
      filter(!is.na(ENSEMBL)) %>%
      mutate(ENSEMBL = sub("\\..*$", "", as.character(ENSEMBL))) %>%
      distinct(SYMBOL, ENSEMBL)
    
    msig2 <- msig %>%
      transmute(gs_name, SYMBOL = gene_symbol) %>%
      inner_join(map, by = "SYMBOL") %>%
      transmute(gs_name, ENSEMBL) %>%
      distinct()
  }
  
  pathways <- split(msig2$ENSEMBL, msig2$gs_name)
  pathways <- lapply(pathways, unique)
  
  # 간단 점검
  cat("Hallmark pathways:", length(pathways), "\n")
  cat("Total unique ENSEMBL in Hallmark:", length(unique(unlist(pathways))), "\n")
  
  pathways
}

suppressPackageStartupMessages({
  library(fgsea)
  library(data.table)
  library(ggplot2)
})

run_fgsea_ens_multilevel <- function(df, comp_name, pathways, outdir,
                          id_col = "gene_id", score_col = "stat",
                          minSize = 15, maxSize = 500, top_plot=5) {
  
  ranks <- make_rank_ens(df, id_col = id_col, score_col = score_col)
  
  fg <- fgseaMultilevel(
    pathways = pathways,
    stats    = ranks,
    minSize  = minSize,
    maxSize  = maxSize
  ) %>% as.data.frame() %>%
    arrange(padj, desc(abs(NES))) %>%
    mutate(comparison = comp_name)
  
  fwrite(fg, file.path(outdir, paste0(comp_name, "_fgsea_ENSEMBL.csv")))
  
  # 상위 enrichment plot 저장 (양/음 각각)
  fg_sig <- fg %>% filter(!is.na(padj)) %>% arrange(padj)
  if (nrow(fg_sig) > 0) {
    top_pos <- fg_sig %>% filter(NES > 0) %>% slice_head(n = top_plot)
    top_neg <- fg_sig %>% filter(NES < 0) %>% slice_head(n = top_plot)
    plot_terms <- unique(c(top_pos$pathway, top_neg$pathway))
    
    for (pw in plot_terms) {
      p <- plotEnrichment(pathways[[pw]], ranks) +
        ggtitle(paste0(comp_name, " | ", pw))
      ggsave(
        filename = file.path(outdir, paste0(comp_name, "__", pw, "_enrichment.png")),
        plot = p, width = 7, height = 4, dpi = 300
      )
    }
  }
  
  fg
}

# 6개 비교 결과 객체 자동 수집

# Hallmark gene set (ENSEMBL로 맞춘 pathways)
pathways_h_ens <- get_hallmark_pathways_ensembl()

outdir <- file.path("rsem", "results", "gsea", "HALLMARK_by_stat_ENSEMBL")
dir.create(outdir, recursive = TRUE, showWarnings = FALSE)

all_fgsea <- dplyr::bind_rows(lapply(names(res_list), function(nm) {
  run_fgsea_ens_multilevel(
    df = res_list[[nm]],
    comp_name = nm,
    pathways = pathways_h_ens,
    outdir = outdir,
    id_col = "gene_id",
    score_col = "stat",
    minSize = 15,
    maxSize = 500,
    top_plot = 5
  )
}))

data.table::fwrite(all_fgsea, file.path(outdir, "ALL_COMPARISONS_fgsea_ENSEMBL.csv"))
-------------------------------------------------------------------------------------------
GOterm으로 GSEA하기.
리스트 만든다음에 진행하기.
get_go_pathways_ensembl <- function(subcategory = c("GO:BP","GO:MF","GO:CC"),
                                    species = "Homo sapiens") {
  subcategory <- match.arg(subcategory)
  
  msig <- msigdbr(species = species, category = "C5", subcollection = subcategory)
  
  if (!("entrez_gene" %in% colnames(msig))) {
    stop("msigdbr 결과에 entrez_gene 컬럼이 없습니다. msigdbr 버전을 확인하세요.")
  }
  
  msig <- msig %>%
    filter(!is.na(entrez_gene)) %>%
    distinct(gs_name, entrez_gene)
  
  entrez_keys <- unique(msig$entrez_gene)
  
  map <- AnnotationDbi::select(
    org.Hs.eg.db,
    keys     = as.character(entrez_keys),
    keytype  = "ENTREZID",
    columns  = c("ENTREZID", "ENSEMBL")
  ) %>%
    filter(!is.na(ENSEMBL)) %>%
    mutate(ENSEMBL = sub("\\..*$", "", as.character(ENSEMBL))) %>%
    distinct(ENTREZID, ENSEMBL)
  
  msig2 <- msig %>%
    mutate(ENTREZID = as.character(entrez_gene)) %>%
    inner_join(map, by = "ENTREZID") %>%
    transmute(gs_name, ENSEMBL) %>%
    distinct()
  
  pathways <- split(msig2$ENSEMBL, msig2$gs_name)
  pathways <- lapply(pathways, unique)
  
  cat("GO subcategory:", subcategory, "\n")
  cat("GO pathways:", length(pathways), "\n")
  cat("Total unique ENSEMBL:", length(unique(unlist(pathways))), "\n")
  
  pathways
}

run_fgsea_go_multilevel <- function(df, comp_name, pathways, outdir,
                                    id_col = "gene_id", score_col = "stat",
                                    minSize = 20, maxSize = 500, top_plot = 5,
                                    padj_plot_cut = 0.05) {
  
  ranks <- make_rank_ens(df, id_col = id_col, score_col = score_col)
  if (length(ranks) < 3000) warning(comp_name, ": ranks too small: ", length(ranks))
  
  fg <- fgseaMultilevel(
    pathways = pathways,
    stats    = ranks,
    minSize  = minSize,
    maxSize  = maxSize
  ) %>% as.data.frame() %>%
    arrange(padj, desc(abs(NES))) %>%
    mutate(comparison = comp_name)
  
  # leadingEdge는 list-column이라 CSV 저장을 위해 문자열로 변환 권장
  fg_out <- fg %>%
    mutate(leadingEdge = vapply(leadingEdge, function(x) paste(x, collapse = ";"), character(1)))
  
  data.table::fwrite(fg_out, file.path(outdir, paste0(comp_name, "_fgsea_GO.csv")))
  
  # 유의한 term만 top_pos/top_neg plot 저장
  fg_sig <- fg %>% filter(!is.na(padj), padj < padj_plot_cut) %>% arrange(padj)
  
  if (nrow(fg_sig) > 0) {
    top_pos <- fg_sig %>% filter(NES > 0) %>% slice_head(n = top_plot)
    top_neg <- fg_sig %>% filter(NES < 0) %>% slice_head(n = top_plot)
    plot_terms <- unique(c(top_pos$pathway, top_neg$pathway))
    
    for (pw in plot_terms) {
      p <- plotEnrichment(pathways[[pw]], ranks) +
        ggtitle(paste0(comp_name, " | ", pw))
      ggsave(
        filename = file.path(outdir, paste0(comp_name, "__", pw, "_enrichment.png")),
        plot = p, width = 7, height = 4, dpi = 300
      )
    }
  }
  
  fg
}

stopifnot(!is.null(names(res_list)) && length(names(res_list)) > 0)

pathways_go_bp <- get_go_pathways_ensembl("GO:BP")
outdir_bp <- file.path("rsem", "results", "gsea", "GO_BP_by_stat_ENSEMBL")
dir.create(outdir_bp, recursive = TRUE, showWarnings = FALSE)

all_go_bp <- dplyr::bind_rows(lapply(names(res_list), function(nm) {
  run_fgsea_go_multilevel(
    df = res_list[[nm]],
    comp_name = nm,
    pathways = pathways_go_bp,
    outdir = outdir_bp,
    minSize = 20, maxSize = 500,
    top_plot = 5,
    padj_plot_cut = 0.05
  )
}))

data.table::fwrite(all_go_bp, file.path(outdir_bp, "ALL_COMPARISONS_fgsea_GO_BP.csv"))

# MF
pathways_go_mf <- get_go_pathways_ensembl("GO:MF")
outdir_mf <- file.path("rsem", "results", "gsea", "GO_MF_by_stat_ENSEMBL")
dir.create(outdir_mf, recursive = TRUE, showWarnings = FALSE)

all_go_mf <- dplyr::bind_rows(lapply(names(res_list), function(nm) {
  run_fgsea_go_multilevel(res_list[[nm]], nm, pathways_go_mf, outdir_mf)
}))
data.table::fwrite(all_go_mf, file.path(outdir_mf, "ALL_COMPARISONS_fgsea_GO_MF.csv"))

# CC
pathways_go_cc <- get_go_pathways_ensembl("GO:CC")
outdir_cc <- file.path("rsem", "results", "gsea", "GO_CC_by_stat_ENSEMBL")
dir.create(outdir_cc, recursive = TRUE, showWarnings = FALSE)

all_go_cc <- dplyr::bind_rows(lapply(names(res_list), function(nm) {
  run_fgsea_go_multilevel(res_list[[nm]], nm, pathways_go_cc, outdir_cc)
}))
data.table::fwrite(all_go_cc, file.path(outdir_cc, "ALL_COMPARISONS_fgsea_GO_CC.csv"))
------------------------------------------------------------------------------------------
1. prom1_TdT_TW vs prom1_TdT

res_use <- res_df %>%
  mutate(SYMBOL = ifelse(grepl("^ENSG", SYMBOL, ignore.case = TRUE), NA, SYMBOL)) %>%
  filter(!is.na(SYMBOL), !is.na(stat))

outdir <- "C:/Users/rkawk/rsem/gsea_input"
dir.create(outdir, showWarnings = FALSE, recursive = TRUE)
write.table(res_use[, c("SYMBOL","stat")],
            file = file.path(outdir, "prom1_TdT_TW vs prom1_TdT.preranked.rnk"),
            sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)
------------------------------------------------------------------------------------------
2. prom1_TdT_TW vs TdT_TW

res_use <- res_df %>%
  mutate(SYMBOL = ifelse(grepl("^ENSG", SYMBOL, ignore.case = TRUE), NA, SYMBOL)) %>%
  filter(!is.na(SYMBOL), !is.na(stat))

outdir <- "C:/Users/rkawk/rsem/gsea_input"
dir.create(outdir, showWarnings = FALSE, recursive = TRUE)
write.table(res_use[, c("SYMBOL","stat")],
            file = file.path(outdir, "prom1_TdT_TW vs TdT_TW.preranked.rnk"),
            sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)

-----------------------------------------------------------------------------------------
3. TdT_vs_TdT_TW

res_use <- res_df %>%
  mutate(SYMBOL = ifelse(grepl("^ENSG", SYMBOL, ignore.case = TRUE), NA, SYMBOL)) %>%
  filter(!is.na(SYMBOL), !is.na(stat))

outdir <- "C:/Users/rkawk/rsem/gsea_input"
dir.create(outdir, showWarnings = FALSE, recursive = TRUE)
write.table(res_use[, c("SYMBOL","stat")],
            file = file.path(outdir, "TdT_vs_TdT_TW.preranked.rnk"),
            sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)
--------------------------------------------------------------------------------------------
4. prom1_TdT vs TdT

res_use <- res_df %>%
  mutate(SYMBOL = ifelse(grepl("^ENSG", SYMBOL, ignore.case = TRUE), NA, SYMBOL)) %>%
  filter(!is.na(SYMBOL), !is.na(stat))

outdir <- "C:/Users/rkawk/rsem/gsea_input"
dir.create(outdir, showWarnings = FALSE, recursive = TRUE)
write.table(res_use[, c("SYMBOL","stat")],
            file = file.path(outdir, "prom1_TdT vs TdT.preranked.rnk"),
            sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)
