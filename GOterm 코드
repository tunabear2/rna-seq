dds 만든 이후에 실행하기.

## -------------------------
## 1) 6개 sig data.frame을 리스트로 묶기
##    (객체명은 네 환경에 맞게 바꿔줘)
## -------------------------
sig_list <- list(
  S1_vs_S2 = S1_vs_S2_sig_genes,
  S1_vs_S3 = S1_vs_S3_sig_genes,
  S1_vs_S4 = S1_vs_S4_sig_genes,
  S2_vs_S3 = S2_vs_S3_sig_genes,
  S2_vs_S4 = S2_vs_S4_sig_genes,
  S3_vs_S4 = S3_vs_S4_sig_genes
)

## 필수 컬럼 체크
stopifnot(all(sapply(sig_list, function(df) all(c("gene_id","log2FoldChange","padj") %in% colnames(df)))))

## -------------------------
## 2) long format으로 합치기 (겹치는 gene OK)
## -------------------------
sig_long <- bind_rows(lapply(names(sig_list), function(nm){
  sig_list[[nm]] %>%
    transmute(
      comp = nm,
      gene_id = as.character(gene_id),
      log2FoldChange = as.numeric(log2FoldChange),
      padj = as.numeric(padj)
    ) %>%
    filter(!is.na(gene_id), gene_id != "")
}))

## -------------------------
## 3) union + 방향성 분리
##    - 대표 log2FC: |log2FC|가 가장 큰 값 (cnetplot 색칠 등에 사용 가능)
## -------------------------
gene_summary <- sig_long %>%
  filter(!is.na(log2FoldChange)) %>%
  group_by(gene_id) %>%
  summarise(
    n_comp  = n_distinct(comp),
    lfc_min = min(log2FoldChange),
    lfc_max = max(log2FoldChange),
    lfc_rep = log2FoldChange[which.max(abs(log2FoldChange))],
    direction = case_when(
      lfc_min > 0 ~ "up_only",
      lfc_max < 0 ~ "down_only",
      TRUE ~ "mixed"
    ),
    .groups = "drop"
  )

union_any       <- gene_summary$gene_id
union_up_only   <- gene_summary %>% filter(direction == "up_only")   %>% pull(gene_id)
union_down_only <- gene_summary %>% filter(direction == "down_only") %>% pull(gene_id)
union_mixed     <- gene_summary %>% filter(direction == "mixed")     %>% pull(gene_id)

cat("union_any:", length(union_any), "\n")
cat("up_only:", length(union_up_only), "\n")
cat("down_only:", length(union_down_only), "\n")
cat("mixed:", length(union_mixed), "\n")

## (선택) foldChange 벡터: 이름=gene_id(ENSEMBL), 값=대표 log2FC
fc_vec <- gene_summary$lfc_rep
names(fc_vec) <- gene_summary$gene_id

## -------------------------
## 4) Universe(background) 준비 (중요)
## ✅ 베스트: DESeq2 dds가 있으면 이걸 쓰는 게 정석
## -------------------------
# bg_ens <- rownames(dds)
bg_ens <- rownames(dds)
## dds가 없으면: "각 비교의 전체 결과(res_df)"에서 모든 gene_id를 모아야 정확해.
## 임시로는(권장X) 아래처럼 union이 아니라 '전체 테스트 gene'이 담긴 프레임을 써야 함.
stopifnot(exists("bg_ens"))  # bg_ens를 네가 위에서 꼭 만들어줘야 한다는 뜻

bg_ens <- unique(as.character(bg_ens))
bg_ens <- bg_ens[!is.na(bg_ens) & bg_ens != ""]

## -------------------------
## 5) enrichGO (ENSEMBL 직접)
## -------------------------
run_enrichGO_ens <- function(genes, universe, ont = c("BP","MF","CC")) {
  genes <- unique(na.omit(genes))
  universe <- unique(na.omit(universe))
  
  res <- lapply(ont, function(o) {
    enrichGO(
      gene          = genes,
      universe      = universe,
      OrgDb         = org.Hs.eg.db,
      keyType       = "ENSEMBL",
      ont           = o,
      pAdjustMethod = "BH",
      pvalueCutoff  = 0.05,
      qvalueCutoff  = 0.05,
      minGSSize     = 10,
      maxGSSize     = 500
    )
  })
  names(res) <- ont
  res
}

ego_any  <- run_enrichGO_ens(union_any,       bg_ens)
ego_up   <- run_enrichGO_ens(union_up_only,   bg_ens)
ego_down <- run_enrichGO_ens(union_down_only, bg_ens)

## -------------------------
## 6) simplify + termsim (선택)
## -------------------------
postprocess <- function(ego_list) {
  ego_s <- lapply(ego_list, function(x){
    if (is.null(x) || nrow(as.data.frame(x)) == 0) return(x)
    x <- clusterProfiler::simplify(x, cutoff = 0.7, by = "p.adjust", select_fun = min)
    x
  })
  ego_sim <- lapply(ego_s, function(x){
    if (is.null(x) || nrow(as.data.frame(x)) == 0) return(x)
    pairwise_termsim(x)
  })
  list(ego_s = ego_s, ego_sim = ego_sim)
}

pp_any  <- postprocess(ego_any)
pp_up   <- postprocess(ego_up)
pp_down <- postprocess(ego_down)

## -------------------------
## 7) 저장 + 그림
## -------------------------
outdir <- file.path("rsem", "results", "go", "UNION")
dir.create(outdir, recursive = TRUE, showWarnings = FALSE)

plot_and_save <- function(enrich_obj, name_prefix, outdir, top = 20) {
  if (is.null(enrich_obj) || nrow(as.data.frame(enrich_obj)) == 0) return(invisible(NULL))
  
  p1 <- dotplot(enrich_obj, showCategory = top) +
    ggtitle(paste0(name_prefix, " — dotplot")) +
    theme(axis.text.y = element_text(size = 8))
  ggsave(file.path(outdir, paste0(name_prefix, "_dotplot.png")),
         p1, width = 8, height = 12, dpi = 300)
  
  p2 <- barplot(enrich_obj, showCategory = top) +
    ggtitle(paste0(name_prefix, " — barplot")) +
    theme(axis.text.y = element_text(size = 8))
  ggsave(file.path(outdir, paste0(name_prefix, "_barplot.png")),
         p2, width = 8, height = 12, dpi = 300)
  
  write.csv(as.data.frame(enrich_obj),
            file.path(outdir, paste0(name_prefix, "_enrich.csv")),
            row.names = FALSE)
}

save_block <- function(pp, tag) {
  lapply(names(pp$ego_s), function(ont){
    plot_and_save(pp$ego_s[[ont]], paste0(tag, "_GO_", ont), outdir, top = 20)
  })
  
  ## BP 네트워크 그림(있을 때만)
  if (!is.null(pp$ego_sim$BP) && nrow(as.data.frame(pp$ego_sim$BP)) > 0) {
    p3 <- emapplot(pp$ego_sim$BP, showCategory = 30)
    ggsave(file.path(outdir, paste0(tag, "_GO_BP_emapplot.png")),
           p3, width = 8, height = 6, dpi = 300)
  }
}

save_block(pp_any,  "UNION_ANY")
save_block(pp_up,   "UNION_UP_ONLY")
save_block(pp_down, "UNION_DOWN_ONLY")
